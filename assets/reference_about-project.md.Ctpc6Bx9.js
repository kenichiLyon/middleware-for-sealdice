import{_ as a,c,o,al as d}from"./chunks/framework.D35TfS0g.js";const h=JSON.parse('{"title":"关于本项目的更多信息","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"reference/about-project.md","filePath":"reference/about-project.md","lastUpdated":1765563126000}'),r={name:"reference/about-project.md"};function t(i,e,n,l,s,p){return o(),c("div",null,[...e[0]||(e[0]=[d('<h1 id="关于本项目的更多信息" tabindex="-1">关于本项目的更多信息 <a class="header-anchor" href="#关于本项目的更多信息" aria-label="Permalink to “关于本项目的更多信息”">​</a></h1><h2 id="本项目的诞生契机" tabindex="-1">本项目的诞生契机 <a class="header-anchor" href="#本项目的诞生契机" aria-label="Permalink to “本项目的诞生契机”">​</a></h2><p>本人作为 Sealdice-core 的深度使用者，由于各种原因，有很多像我这样有些技术的用户，被迫将协议端程序从 Windows 环境迁移至 Linux 环境，或反之；而在分离部署这个 case 下，因为海豹核心只传输 URI，在分开两个网络环境部署时，海豹核心与协议端无法正常发送图片、语音等外置资源，这也确实给我与用户带来了不便</p><p>@<a href="https://github.com/PaineNate" target="_blank" rel="noreferrer">PaineNate</a> 派恩纳特老师与 @<a href="https://github.com/Szzrain" target="_blank" rel="noreferrer">Szzrain</a> Szzrain 老师在海豹核心烹饪群的讨论启发了我，我自己动手制作了这个项目试图解决这个问题。在这里再次感谢派恩纳特老师与 Szzrain 老师。</p><p>本人技术力有限，只实现了 <code>a + b</code> 方案，<code>c</code> 方案由社区贡献，本仓库设置为 monorepo 模式也有考量到社区会有更多有能技术佬实现更多的模式，希望本项目能为海豹社区提供一个可能的设想。</p><h2 id="a-b-方案的原理" tabindex="-1"><code>a + b</code> 方案的原理 <a class="header-anchor" href="#a-b-方案的原理" aria-label="Permalink to “a + b 方案的原理”">​</a></h2><p>这里借鉴了 FTP 的模式，设置两个程序，一个是 <code>middleware-a</code>，一个是 <code>middleware-b</code>，为方便称呼下面简称 <code>a</code> 与 <code>b</code>。</p><p><code>a</code>负责与协议端和 sealdice-core 两个程序进行通信，拦截并覆写 sealdice-core 的 message 事件和 cqcode 中关于 URI 的部分，同时，将 URI 的文件转发到到 <code>b</code>，将 <code>b</code> 返回的文件路径替换为协议端可以访问的 URI，从而实现问题的解决。</p><p><code>b</code> 则负责接收 <code>a</code> 转发的文件，将其存储至本地，然后返回文件的本地的绝对路径。这也是为什么 <code>b</code> 必须要与协议端程序在同一台机器上才能正常工作。</p><p>实质上，<code>a</code> 与 <code>b</code>两程序将文件从 sealdice-core 程序所在的机器转发到了协议端程序所在的机器，从而实现了问题的解决。</p><h2 id="c-方案的原理" tabindex="-1"><code>c</code> 方案的原理 <a class="header-anchor" href="#c-方案的原理" aria-label="Permalink to “c 方案的原理”">​</a></h2><p><code>c</code> 方案与 <code>a + b</code> 方案不同，<code>c</code> 方案只需要启动一个程序 <code>middleware-c</code>，就可以实现问题的解决。</p><p><code>c</code> 负责与协议端和 sealdice-core 两个程序进行通信，把所有外置的多媒体文件资源转为 base64 编码，之后与<code>a</code>类似，覆写 sealdice-core 的 message 事件和 cqcode 中关于 URI 的部分，将原先的 URI 替换为 base64 路径，从而实现问题的解决。</p>',13)])])}const _=a(r,[["render",t]]);export{h as __pageData,_ as default};
